下面这份是**已经按“问题描述 → 假设与符号说明 → 算法设计 → 实验仿真”重构好的完整方案**，你可以直接当作：

* `设计大纲.md`
* 或论文的主体框架（2–5 章）

来用。

---

# 智能制造生产调度系统设计与实验方案

## 第 1 章 引言（项目背景）

某智能制造工厂拥有三条生产线，每条生产线均可加工 3 种产品。企业每天早上 8 点根据当前订单情况生成未来一段时间的生产计划；当天 8 点之后到来的新订单，将在下一天早上 8 点统一纳入调度。

在订单具有不同交付期限和违约罚款的情况下，如何在有限产能和人工成本约束下合理安排生产，使企业总利润最大化，是一个典型的 NP 困难调度优化问题。

本项目目标是：
基于《计算智能》课程中所学的遗传算法（GA）和局部搜索算法（ILS/VNS），设计并实现一套**智能制造生产调度系统**，完成生产计划自动生成、滚动重调度与结果可视化，并用于课程大作业展示和论文撰写。

---

## 第 2 章 问题描述与建模

### 2.1 问题描述

工厂具备如下生产特性：

* 共有 3 条并行生产线，能力相同；
* 每条产线可加工 3 种不同产品中的任意一种；
* 时间被离散为以 4 小时为单位的时间段（time slot），每天共 6 个时间段；
* 企业每天 8 点根据当前订单集合制定未来一段时间的生产计划；
* 订单具有产品类型、需求数量、单价和最迟交付时间等属性，若未按时完成，将产生罚款。

需要设计一个调度算法，使得：

* 在满足产能约束与订单截止时间约束的前提下；
* 对未来若干时间段内每条生产线的产品安排与订单分配进行优化；
* 最大化企业总利润（销售收入 − 人工成本 − 违约罚款）。

当新订单到来时，在下一次每日 8 点重启调度过程，形成**滚动调度**。

### 2.2 问题假设

根据课程大作业要求，作出如下假设：

1. 三条生产线之间能力完全相同。
2. 以 4 小时为一个时间段（time slot），每个时间段内一条生产线**只能生产一种产品**，产品切换无需额外成本。
3. 原材料供应充足，不构成约束。
4. 工人生产能力相同，不考虑个体差异。
5. 工人工资按 4 小时结算，单位人工成本随时间段变化：越偏离正常工作时间，成本越高。
6. 所有其他成本（设备折旧、管理费用等）折算进入生产费用中，不单独建模。
7. 如果订单在截止时间前未完全完成，需要支付该订单总金额 10% 的罚款（无论完成多少）。
8. 每天早上 8 点统一生成生产计划，当天 8 点之后到来的订单，放入下一天的调度中统一安排。
9. 忽略生产过程中的意外情况，假设所有设备、人员均能正常工作。
10. 每条生产线只能生产这 3 种产品之一或保持空闲。
11. 合同的截止时间均指截止日期当天早上 8 点，对应为某一时间段索引。
12. 当多个订单同时加工且尾数工件不足 4 小时时，可以在同一时间段内合并生产同类产品，只要不超过该时间段产能。

### 2.3 符号说明

* 集合与索引

  * 生产线集合：$L = {1,2,3}$
  * 产品集合：$P = {1,2,3}$
  * 时间段集合（以 4 小时为单位）：一天 6 个 slot，规划未来 $D$ 天，共
    $T = {1,2,\dots,H}$，其中 $H = 6D$
  * 订单集合：$O = {1,2,\dots,N}$

* 订单参数（对任意 $o \in O$）：

  * 产品类型：$p_o \in P$
  * 需求数量：$q_o$
  * 单位售价：$s_o$
  * 截止时间（以 slot 为单位）：$d_o$

* 产能参数：

  * 每条生产线在一个时间段内对产品 $p$ 的最大产量：$cap_p$

* 成本参数：

  * 每个时间段 $t$ 的单位人工成本：$c_t$
    （由时间段对应的班次决定，夜班成本更高）

* 决策变量：

  * 结构层决策（由 GA 控制）

    * $x_{l,t} \in {0,1,2,3}$
      表示生产线 $l$ 在时间段 $t$ 的生产产品类型：
      0 = 空闲，1/2/3 = 三种产品之一。
  * 分配层决策（由解码/启发式确定）

    * $y_{o,l,t} \ge 0$：订单 $o$ 在生产线 $l$、时间段 $t$ 上的生产数量
    * 订单实际完成量：
      $q_o^{done} = \sum_{l \in L} \sum_{t \le d_o} y_{o,l,t}$

* 辅助变量：

  * $WorkIndicator_{l,t} = 1$：若 $x_{l,t} \neq 0$（该 slot 有生产），否则为 0。

### 2.4 数学模型

**目标：最大化总利润**

1. 收入：
   [
   Revenue = \sum_{o \in O} q_o^{done} \cdot s_o
   ]

2. 人工成本：
   [
   Cost = \sum_{l \in L} \sum_{t \in T} c_t \cdot WorkIndicator_{l,t}
   ]

3. 罚款：
   [
   Penalty = \sum_{o \in O : q_o^{done} < q_o} 0.1 \cdot q_o \cdot s_o
   ]
   （注：只要订单未完全完成，罚款即为订单总金额的10%）

4. 目标函数：
   [
   \max Profit = Revenue - Cost - Penalty
   ]

**约束条件：**

1. 单产品约束（每产线每时间段最多生产一种产品）：
   [
   x_{l,t} \in {0,1,2,3} \quad \forall l \in L, t \in T
   ]

2. 产能约束（同一 slot 同一产品订单可合并）：
   [
   \sum_{o : p_o = p} y_{o,l,t} \le cap_p \quad \text{当 } x_{l,t}=p
   ]

3. 订单完成量约束：
   [
   0 \le q_o^{done} \le q_o, \quad q_o^{done} = \sum_{l \in L} \sum_{t \le d_o} y_{o,l,t}
   ]

4. 非负约束：
   [
   y_{o,l,t} \ge 0
   ]

尾数合并通过“同一时间段、同一产品的 $y_{o,l,t}$ 之和不超过 $cap_p$”自然体现。

---

## 第 3 章 算法设计

本系统采用 **“遗传算法（GA）+ 局部搜索（ILS/VNS）+ 滚动调度”** 的混合计算智能框架。

### 3.1 总体框架

1. **上层：遗传算法（GA）**

   * 将“生产线–时间段–产品类型”的结构及订单优先级编码为染色体；
   * 通过选择、交叉、变异迭代优化，进行全局搜索。

2. **解码与启发式订单分配**

   * 给定结构变量 $x_{l,t}$ 与订单优先级序列，采用贪心分配策略，在满足产能与截止时间约束的前提下，为每个订单分配可用产能。

3. **局部搜索（ILS / VNS）**

   * 以 GA 当前最优解为初始解，通过局部邻域操作（交换时间段产品、微调订单分配）进一步优化利润，提升解质量。

4. **滚动调度机制**

   * 每天早上 8 点触发一次调度；
   * 冻结当前时间之前已执行的调度，重新优化未来尚未开始的时间段；
   * 新订单在下一次 8 点统一加入订单池参与调度。

### 3.2 染色体编码与解码策略

**染色体结构：**
$$Chromosome = [Gene1, Gene2]$$

1. **Gene1：产线–时间–产品结构编码**

   * 长度为 $3 \times H$ 的整数数组；
   * 下标 $k$ 对应某条生产线 $l$ 和时间段 $t$，值含义：

     * 0：空闲
     * 1 / 2 / 3：对应产品 1 / 2 / 3

2. **Gene2：订单优先级排列**

   * 长度为 $N$ 的订单编号排列 $[o_1,o_2,\dots,o_N]$；
   * 解码时按此顺序为订单分配产能。

**解码过程（伪代码）：**

```text
Input: Gene1, Gene2, 订单集合 O, 产能 cap_p, 截止时间 d_o
Output: 调度方案 {y_{o,l,t}}, 完成量 {q_o^{done}}, 利润 Profit

1. 初始化所有 y_{o,l,t} = 0
2. 根据 Gene1 和 cap_p 计算每个 (l,t) 对应产品的可用产能 availCap[l,t]
3. 对 Gene2 中的订单 o 按顺序依次处理：
   3.1 target_product = p_o
   3.2 在所有满足 x_{l,t} = target_product 且 t <= d_o 的 slot 中，按时间升序遍历：
       - 可分配量 = min(availCap[l,t], 订单剩余需求)
       - 更新 y_{o,l,t}、availCap[l,t] 和剩余需求
       - 若订单 o 已完成则跳出
4. 计算每个订单的完成量 q_o^{done}
5. 根据 y_{o,l,t} 计算 Revenue, Cost, Penalty 和 Profit
6. 返回 Profit 作为适应度值
```

尾数合并通过“在同一 (l,t) 上为多个同产品订单分配部分产量”实现。

### 3.3 适应度函数与约束处理

* 对每个染色体执行上述解码过程；
* 适应度定义为总利润：
  [
  Fitness = Profit = Revenue - Cost - Penalty
  ]

通过编码和解码策略确保：

* 不出现违反产能上限的分配；
* 不在截止时间之后为订单分配产量（或将晚于截止时间部分视为违约处理）。

如后续扩展引入其他操作导致潜在不可行情况，可在适应度中加入惩罚项进行修正。

### 3.4 遗传算法流程设计

1. **初始化种群**

   * 种群规模 PopSize（如 50–100）；
   * Gene1 随机生成（随机指定每个 slot 的产品或空闲）；
   * Gene2 生成随机订单排列；
   * 可加入基于简单规则（如最早截止日期优先）的启发式个体丰富初始解。

2. **选择算子**

   * 采用**锦标赛选择**或**轮盘赌选择**，使适应度高的个体有更大概率进入下一代。

3. **交叉算子**

   * 对 Gene1：采用按时间轴切片的单点交叉或多点交叉；
   * 对 Gene2：使用 OX（顺序交叉）或 PMX（部分映射交叉）保证子代仍为合法排列。

4. **变异算子**

   * Gene1：随机选择若干基因位置，将产品类型改为其他合法值 ${0,1,2,3}$；
   * Gene2：随机交换两个订单编号（swap 变异）。

5. **精英保留策略**

   * 每代保留若干最优个体直接复制到下一代，防止优良解被随机操作破坏。

6. **终止条件**

   * 达到最大迭代次数 MaxGen；
   * 或连续若干代最优适应度提升小于预设阈值。

### 3.5 局部搜索策略（ILS/VNS）

为进一步提升 GA 求得解的质量，引入迭代局部搜索（ILS）/变邻域搜索（VNS），在 GA 最优解基础上进行解精化。

**邻域结构示例：**

* 邻域 N1：**交换时间段产品**

  * 随机选定一条生产线 $l$ 和两个时间段 $t_1,t_2$，交换 Gene1 中对应位置的产品类型；
* 邻域 N2：**微调订单分配**

  * 在固定 Gene1 不变的前提下，选择某一订单 $o$，在其可用 slot 内（满足产品类型和截止时间）尝试将部分产量从某个 slot 移到另一个成本更低或更接近截止时间的 slot。

**ILS/VNS 伪代码：**

```text
Input: GA 最优解 c_best
Parameters: MaxLSIter, 邻域集合 {N1, N2, ...}

for iter = 1 .. MaxLSIter:
    随机选择一个邻域结构 Nk
    在 c_best 上应用 Nk 生成邻域解 c_new
    解码 c_new，计算 Fitness(c_new)
    if Fitness(c_new) > Fitness(c_best):
        c_best = c_new     // 接受改进解
return c_best
```

如需体现 VNS 思想，可按照邻域序号逐步扩展搜索范围，若发现更优解则重置为第一个邻域。

### 3.6 动态滚动调度策略

* 时间轴按天划分，每天 8 点为重调度时刻；

* 每日调度步骤：

  1. 收集所有未完成订单及前一日 8 点后到来的新订单，形成订单池；
  2. 冻结当前时间之前已经执行的调度，不再修改；
  3. 以当前 8 点为起点，对未来 $H$ 个时间段运行 GA + 局部搜索得到最优排程方案；
  4. 将方案映射回全局时间轴，更新未来几天的生产计划。

* 历史解利用（可选优化）：

  * 在新一轮 GA 初始化时，将上一轮最优解中尚未开始的部分作为若干“精英初始个体”，加速收敛并保持排程连续性。

---

## 第 4 章 系统实现与软件架构（对应代码结构）

### 4.1 模块划分

建议软件系统采用如下模块划分（Python 示例）：

1. **订单管理模块（OrderManager）**

   * 管理订单的增删改查；
   * 维护订单池（未完成订单 + 新订单）；
   * 实现实时时间到 slot 索引的转换。

2. **调度引擎模块（Scheduler）**

   * 负责每日 8 点的滚动调度；
   * 调用 GA 引擎和局部搜索模块；
   * 维护当前生产计划。

3. **GA 引擎模块（GAEngine）**

   * 实现染色体结构、种群初始化、选择、交叉、变异；
   * 调用解码模块计算适应度。

4. **解码与评估模块（Decoder & Evaluator）**

   * 根据染色体生成具体调度方案 $y_{o,l,t}$；
   * 计算 Revenue、Cost、Penalty、Profit 等指标。

5. **局部搜索模块（LocalSearch）**

   * 实现邻域操作和 ILS/VNS 流程；
   * 在 GA 最优解基础上进行解精化。

6. **可视化与展示模块（Visualization）**

   * 生成生产甘特图；
   * 统计并展示关键指标（利润、按期率、产线负载等）；
   * 为课程展示输出图表和数据。

### 4.2 核心数据结构（示例）

* `Order`：

  * 字段：`id, product, quantity, remaining, due_slot, unit_price` 等。
* `Chromosome`：

  * 字段：`gene1: List[int]`, `gene2: List[int]`, `fitness: float`。
* `Schedule`：

  * 存储 $y_{o,l,t}$ 及相关统计方法（订单完成量、slot 工作状态等）。

### 4.3 系统运行流程（整体）

```text
初始化系统参数与订单数据
for 每一天:
    时间到达 8 点:
        1. 更新订单池（加入新订单，更新未完成订单的 remaining）
        2. 冻结已执行的调度
        3. 调用 Scheduler:
            - 运行 GAEngine 生成若干代调度方案
            - 取 GA 最优解，交给 LocalSearch 做一轮局部优化
            - 生成最终调度计划（未来 H 个 slot）
        4. 保存并可视化当天的调度结果
    按时间推进执行调度，更新订单完成情况
```

---

## 第 5 章 实验仿真与评估方案

### 5.1 实验环境与参数设置

* 硬件环境：CPU / 内存等（论文时填）
* 软件环境：Python 版本、依赖库版本等
* GA 参数：

  * 种群规模 PopSize（如 50–100）
  * 最大迭代次数 MaxGen（如 100–300）
  * 交叉概率 $P_c$（如 0.7–0.9）
  * 变异概率 $P_m$（如 0.05–0.1）
* 局部搜索参数：

  * 最大迭代次数 MaxLSIter
  * 邻域类型与触发策略
* 成本参数：

  * 各时间段人工成本 $c_t$（白班、晚班、夜班等）
* 产能参数：

  * 各产品在单条产线上每个 slot 的产能 $cap_p$

### 5.2 测试算例设计

设计多组订单场景：

1. **小规模算例**

   * 订单数量较少（如 10–20 单），用于验证算法正确性与可视化效果。
2. **中等规模算例**

   * 订单数量适中（如 50–100 单），用于评估算法性能与运行时间。
3. **不同截止时间分布场景**

   * 截止时间集中在某几天（高峰交付）
   * 截止时间均匀分布（平稳生产）

### 5.3 对比算法设计

为了评价所提算法效果，设计以下对比方案：

1. **规则调度算法（Baseline）**

   * 例如“最早截止时间优先（EDD）+ 固定产品节奏”的简单启发式。
2. **仅用 GA，不加局部搜索**

   * 评估局部搜索对解质量和收敛速度的提升作用。
3. **GA + ILS/VNS（本文算法）**

   * 完整的混合智能优化框架。

### 5.4 评价指标

* **总利润 Profit**（核心指标）
* **订单按期完成率**（按时完成的订单数量/总订单数）
* **总罚款金额**
* **产线平均负载率**（实际工作时间 / 可用时间）
* **算法运行时间**
* （可选）GA 收敛曲线（迭代次数 vs 最优适应度）

实验仿真完成后，可通过表格与图形（折线图/柱状图）对不同算法、不同算例下指标进行比较分析。

### 5.5 可视化与展示

* 绘制典型一天/多天的生产甘特图：

  * 横轴为时间段，纵轴为生产线编号；
  * 不同颜色表示不同产品或不同订单。
* 输出订单完成情况表：

  * 订单需求量、完成量、是否按期、罚款金额等。
* 展示 GA 收敛曲线与“仅 GA vs GA+ILS”的对比曲线，直观说明局部搜索的作用。

---

## 第 6 章 小结与扩展方向（简要）

本方案基于遗传算法和局部搜索，构建了一个适用于三条生产线、三种产品的智能制造生产调度系统，实现了利润最大化意义下的自动排产与滚动调度。

与课程内容的紧密对应关系：

* 采用 **遗传算法（GA）** 作为主干搜索算法（编码、选择、交叉、变异、适应度等）；
* 引入 **局部搜索类算法（ILS/VNS）** 对 GA 解进行精细优化；
* 可在局部搜索的接受策略中融入 **模拟退火（SA）思想** 或 **禁忌搜索（TS）记忆机制** 作为扩展。

潜在扩展方向包括：

* 多目标优化（利润 + 负载均衡 + 加班时间）；
* 引入粒子群（PSO）、蚁群优化（ACO）、免疫算法（IA）、EDA 等其他智能算法进行对比；
* 考虑订单随机变更、设备故障等不确定性，构建鲁棒调度模型；
* 探索基于强化学习的在线调度策略。

---

这样改完之后：

* **问题描述**：第 2.1 节
* **问题假设与符号说明**：第 2.2 + 2.3 + 2.4
* **算法设计**：第 3 章（+ 第 4 章若论文偏工程）
* **实验仿真**：第 5 章

你可以直接整章整章往论文里搬，也可以原样作为 `设计大纲.md` 喂给 Cursor 让它实现代码。
