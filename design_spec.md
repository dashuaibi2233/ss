# 智能制造生产调度系统设计与实验方案 - 需求规范

> **文档说明**: 本文档是系统设计的权威依据，所有代码修改必须以此为准。
> 
> **更新时间**: 2025-12-11
> 
> **核心变更**: 引入订单随机到达机制，实现真正的动态滚动调度

---

## 一、建模层/文档层修改

### 1. 第 2.1 节：问题描述——替换/增强

**现在是：**
> 企业每天 8 点根据当前订单集合制定未来一段时间的生产计划；
> 订单具有产品类型、需求数量、单价和最迟交付时间等属性，若未按时完成，将产生罚款。

**建议改成（直接覆盖下面这两句即可）：**

> **订单不再假设在第 1 天一次性给出，而是在整个计划期内随机到达。每个订单到达时才会被工厂"看到"。**
> 
> **工厂每天早上 8 点根据当前已到达且尚未完成的订单集合制定未来一段时间的生产计划；当天 8 点之后到达的新订单，将在下一天早上 8 点统一纳入调度。**

这样文字上已经说明"随机到达 + 每天 8 点滚动"。

---

### 2. 第 2.2 节：问题假设——补充一个"到达时间"的假设

你原来假设 7、8 已经有罚款和 8 点规则了，现在加一条关于到达时间：

可以在假设 7 和 8 之间插一条，比如变成：

7. 如果订单在截止时间前未完全完成，需要支付该订单总金额 10% 的罚款（无论完成多少）。

**8. 每个订单具有一个到达时间（或到达时间段），订单只有在到达之后才可以被安排生产。**

**9. 每天早上 8 点统一生成生产计划，当天 8 点之后到来的订单，放入下一天的调度中统一安排。**

（后面原来的 8、9、10… 依次+1 编号即可，或者保持你原有编号顺序也行）

---

### 3. 第 2.3 符号说明——给订单加一个"到达时间"

**现在订单参数部分是：**

订单参数（对任意 $o \in O$）：
- 产品类型：$p_o \in P$
- 需求数量：$q_o$
- 单位售价：$s_o$
- 截止时间（以 slot 为单位）：$d_o$

**改成：**

订单参数（对任意 $o \in O$）：
- 产品类型：$p_o \in P$
- 需求数量：$q_o$
- 单位售价：$s_o$
- **到达时间（以 slot 为单位）：$r_o$，订单在 $t \ge r_o$ 时才允许被安排生产**
- 截止时间（以 slot 为单位）：$d_o$

---

### 4. 解码伪代码——加上"只能用到达后的 slot"

**你现在的解码伪代码是：**

```
3.2 在所有满足 x_{l,t} = target_product 且 t <= d_o 的 slot 中，按时间升序遍历：
```

**为了体现"订单要到达之后才可以生产"，改成：**

```
3.2 在所有满足 x_{l,t} = target_product 且 r_o <= t <= d_o 的 slot 中，按时间升序遍历：
```

也就是多了一个 `r_o <= t` 的条件。

这样数学模型和算法描述上都已经支持"随机到达 + 截止时间"。

---

### 5. 第 3.6 动态滚动调度策略——把"随机到达"写清楚

**你现在写的是：**

> 收集所有未完成订单及前一日 8 点后到来的新订单，形成订单池；

**可以细化成下面这样（直接替换那一条）：**

> **收集订单池：将所有满足"到达时间 $r_o$ 小于等于当前 8 点对应的时间段起点、且尚未完成"的订单加入订单池；对于当前这一天 8 点之后（即 $r_o$ 大于当前起始 slot）到达的新订单，不立刻调度，而是在下一天 8 点的调度时加入订单池。**

这样和你想要的业务规则就完全一致了。

---

## 二、实现层（代码逻辑）修改说明

> **以下内容可以直接提供给 Cursor 作为代码修改指导**

### 代码修改要求

1. **在订单数据结构 `Order` 和 CSV 里增加字段 `release_slot`（或 `arrival_slot`）**，对应我方案里的 $r_o$，表示订单最早可开始生产的时间段。

2. **在滚动调度时**，第 `day` 天早上 8 点对应的起始时间段是 `current_start_slot`。

3. **当天参与调度的订单集合为：**
   ```python
   orders = { o | o.remaining > 0 and o.release_slot <= current_start_slot }
   ```
   所有 `release_slot > current_start_slot` 的订单，视为"未来订单"，这轮调度不考虑，等到某一天 8 点满足条件再加入。

4. **在解码/分配阶段**，为订单 `o` 分配产能时，只允许使用 `t` 满足：
   ```python
   release_slot[o] <= t <= due_slot[o]
   ```
   也就是：**必须在订单到达之后、且不晚于截止时间**。

5. **每一天仿真结束后**，推进 `current_slot`，并在下一次 8 点调度之前，把所有 `release_slot` 介于"上一天 8 点"和"今天 8 点"之间的新订单，统一加入订单池。

### 需要修改的模块

你可以把这几条写成英文/中文注释，让 Cursor 去改以下三个模块：

- **`OrderManager`** - 订单管理器，增加 `release_slot` 字段处理
- **`RollingScheduler`** - 滚动调度器，实现"只调度已到达订单"的逻辑
- **`Decoder`** - 解码器，增加 `r_o <= t` 的约束条件

---

## 三、规范版文字描述（可写入论文）

> **建议在第 2 章或第 3.6 节加入以下总结性描述：**

在本系统中，订单到达是动态的。每个订单 $o$ 具有到达时间 $r_o$ 和截止时间 $d_o$。企业采用日滚动调度策略：每天早上 8 点，将所有满足 $r_o$ 不大于当前 8 点、且尚未完成的订单纳入订单池，调用"GA + 局部搜索"进行重新排产；当日 8 点之后到达的新订单不会立刻被安排，而是推迟到下一天 8 点统一加入订单池参与调度。这样既体现了订单随机到达的现实特征，又保证了调度策略在时间轴上的可实现性。

---

## 四、实施检查清单

### 建模层修改
- [ ] 更新第 2.1 节问题描述
- [ ] 更新第 2.2 节问题假设（增加假设 8、9）
- [ ] 更新第 2.3 节符号说明（订单参数增加 $r_o$）
- [ ] 更新第 3.2 节解码伪代码（增加 `r_o <= t` 约束）
- [ ] 更新第 3.6 节滚动调度策略（细化订单池收集规则）

### 代码层修改
- [ ] `models/order.py` - 增加 `release_slot` 字段
- [ ] `scheduler/order_manager.py` - 实现"只返回已到达订单"的逻辑
- [ ] `scheduler/rolling_scheduler.py` - 修改每日调度的订单筛选条件
- [ ] `ga/decoder.py` - 增加 `r_o <= t <= d_o` 的时间窗口约束
- [ ] `data/*.csv` - 为所有订单数据增加 `release_slot` 列

### 测试验证
- [ ] 创建包含随机到达时间的测试数据集
- [ ] 验证"8点之后到达的订单不会立即调度"
- [ ] 验证"订单只能在到达后被分配产能"
- [ ] 验证滚动调度的订单池更新逻辑
- [ ] 对比修改前后的调度结果差异

---

## 五、数据格式示例

### 原有 CSV 格式
```csv
order_id,product,quantity,due_slot,unit_price
1,1,324,6,60
2,1,486,6,57
```

### 新增 `release_slot` 后的格式
```csv
order_id,product,quantity,release_slot,due_slot,unit_price
1,1,324,1,6,60
2,1,486,3,6,57
3,2,301,5,12,72
```

**说明：**
- `release_slot=1` 表示订单在第 1 个 slot 到达（第 1 天早上 8 点之前）
- `release_slot=3` 表示订单在第 3 个 slot 到达
- 订单只能在 `release_slot <= t <= due_slot` 的时间窗口内被安排生产

---

## 六、后续扩展方向

1. **订单到达模式**
   - 均匀随机到达
   - 泊松分布到达
   - 批量到达（每天固定时间到达一批）

2. **紧急订单处理**
   - 允许插单（高优先级订单立即调度）
   - 动态调整已有计划

3. **预测性调度**
   - 基于历史数据预测未来订单
   - 预留部分产能应对不确定性

---

**文档版本**: v2.0  
**最后更新**: 2025-12-11  
**维护者**: 需求分析助手
