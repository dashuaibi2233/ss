# 算法设计文档

## 概述

本文档详细描述智能制造生产调度系统中使用的算法设计，基于《设计大纲.md》第3章内容整理。

系统采用**"遗传算法（GA）+ 局部搜索（ILS/VNS）+ 滚动调度"**的混合计算智能框架。

---

## 1. 问题建模

### 1.1 数学模型

**目标函数：最大化总利润**

```
max Profit = Revenue - Cost - Penalty
```

其中：
- **Revenue（收入）**: ∑ q_o^done × s_o
- **Cost（人工成本）**: ∑∑ c_t × WorkIndicator_{l,t}
- **Penalty（罚款）**: ∑_{o: q_o^done < q_o} 0.1 × q_o × s_o
  - 注：只要订单未完全完成，罚款即为订单总金额的10%

**约束条件：**
1. 单产品约束：每条生产线每个时间段最多生产一种产品
2. 产能约束：同一时间段同一产品的总产量不超过产能上限
3. 订单完成量约束：0 ≤ q_o^done ≤ q_o
4. 截止时间约束：只能在截止时间之前为订单分配产能

### 1.2 决策变量

- **x_{l,t}**: 生产线 l 在时间段 t 的产品类型（0=空闲，1/2/3=产品）
- **y_{o,l,t}**: 订单 o 在生产线 l、时间段 t 的生产数量

---

## 2. 遗传算法（GA）

### 2.1 染色体编码

**双层编码结构：**

```
Chromosome = [Gene1, Gene2]
```

**Gene1：产线-时间-产品结构编码**
- 长度：3 × H（3条生产线 × H个时间段）
- 值域：{0, 1, 2, 3}
  - 0：该时间段空闲
  - 1/2/3：生产对应产品

**Gene2：订单优先级排列**
- 长度：N（订单总数）
- 值域：订单编号的排列 [o_1, o_2, ..., o_N]
- 解码时按此顺序为订单分配产能

### 2.2 解码过程

将染色体转换为具体调度方案的步骤：

```
输入：Gene1, Gene2, 订单集合, 产能参数
输出：调度方案 {y_{o,l,t}}, 利润值

1. 根据 Gene1 计算每个 (l,t) 的可用产能 availCap[l,t]
2. 按 Gene2 中的订单顺序依次处理：
   a. 获取订单的产品类型和剩余需求
   b. 在满足条件的 (l,t) 中按时间升序分配产能：
      - 条件：x_{l,t} = 目标产品 且 t ≤ 截止时间
      - 分配量 = min(availCap[l,t], 剩余需求)
   c. 更新 y_{o,l,t} 和 availCap[l,t]
3. 计算总利润作为适应度值
```

### 2.3 适应度函数

```python
def fitness(chromosome):
    schedule = decode(chromosome)
    revenue = calculate_revenue(schedule)
    cost = calculate_cost(schedule)
    penalty = calculate_penalty(schedule)
    return revenue - cost - penalty
```

### 2.4 遗传操作

**初始化**
- 种群规模：PopSize（50-100）
- Gene1：随机生成或基于启发式规则
- Gene2：随机排列或按截止时间排序（EDD）

**选择算子**
- 锦标赛选择（Tournament Selection）：随机选k个个体，取最优
- 轮盘赌选择（Roulette Wheel Selection）：按适应度比例选择

**交叉算子**
- Gene1：单点交叉或多点交叉
- Gene2：顺序交叉（OX）或部分映射交叉（PMX），保证合法排列

**变异算子**
- Gene1：随机改变若干位置的产品类型
- Gene2：随机交换两个订单位置（Swap Mutation）

**精英保留**
- 每代保留前 k 个最优个体直接进入下一代

**终止条件**
- 达到最大迭代次数 MaxGen
- 或连续若干代适应度无显著提升

---

## 3. 局部搜索（ILS/VNS）

### 3.1 目标

在 GA 得到的最优解基础上，通过局部邻域操作进一步提升解质量。

### 3.2 邻域结构

**邻域 N1：交换时间段产品**
- 随机选择一条生产线 l 和两个时间段 t1, t2
- 交换 Gene1 中对应位置的产品类型
- 重新解码并计算适应度

**邻域 N2：微调订单分配**
- 固定 Gene1 不变
- 选择某个订单，尝试将部分产量从一个时间段移到另一个
- 目标：降低成本或减少罚款

### 3.3 搜索流程

```
输入：GA最优解 c_best
参数：MaxLSIter, 邻域集合 {N1, N2}

for iter = 1 to MaxLSIter:
    随机选择邻域 Nk
    生成邻域解 c_new = Nk(c_best)
    计算 fitness(c_new)
    
    if fitness(c_new) > fitness(c_best):
        c_best = c_new  # 接受改进解
        
return c_best
```

**VNS 扩展**：
- 按邻域序号逐步扩展搜索范围
- 发现更优解时重置为第一个邻域

---

## 4. 滚动调度策略

### 4.1 调度时机

- 每天早上 8:00 触发一次调度
- 当天 8:00 之后到来的新订单放入下一天调度

### 4.2 滚动调度流程

```
每日 8:00:
1. 收集订单池：
   - 所有未完成订单
   - 前一日 8:00 后到来的新订单
   
2. 冻结已执行调度：
   - 当前时间之前的时间段不再修改
   
3. 运行优化算法：
   - 对未来 H 个时间段运行 GA + 局部搜索
   - 得到最优调度方案
   
4. 更新生产计划：
   - 将方案映射回全局时间轴
   - 保存并可视化
```

### 4.3 历史解利用（可选）

- 将上一轮最优解中尚未开始的部分作为精英初始个体
- 加速收敛并保持排程连续性

---

## 5. 算法整体框架

```
主流程：
1. 初始化系统参数和订单数据
2. for 每一天:
     if 时间到达 8:00:
         a. 更新订单池
         b. 冻结已执行时间段
         c. 运行 GA 引擎（若干代进化）
         d. 取 GA 最优解
         e. 运行局部搜索优化
         f. 生成最终调度方案
         g. 可视化结果
     按时间推进，执行调度，更新订单状态
```

---

## 6. 参考

详细算法伪代码和数学公式请参考《设计大纲.md》第3章。
